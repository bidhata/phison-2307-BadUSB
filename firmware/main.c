#include "defs.h"
#include "timers.h"
#include "usb.h"

extern void usb_isr(void) __interrupt USB_VECT;
extern void ep_isr(void) __interrupt EP_VECT;
extern void tmr0isr(void) __interrupt TMR0_VECT;
extern void tmr1isr(void) __interrupt TMR1_VECT;
extern void com0isr(void) __interrupt COM0_VECT;

#define KEY_DELAY 8192
#define KEY_BUFFER_SIZE 0x2000
static const BYTE keyData[KEY_BUFFER_SIZE] = { /*0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xC3,
	0x15, 0x08, 0x00, 0xFF, 0x00, 0xF5, 0x11, 0x00, 0x12, 0x00, 0x17, 0x00, 0x08, 0x00, 0x13,
	0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0xFF, 0x00, 0xF5, 0x28, 0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0xF0, 0x0B, 0x02, 0x08, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x12, 0x00, 0x2C, 0x00, 0x1A,
	0x02, 0x12, 0x00, 0x15, 0x00, 0x0F, 0x00, 0x07, 0x00, 0x1E, 0x02, 0x1E, 0x02, 0x1E, 0x02,
	0x28, 0x00*/ 0x12, 0x34, 0x56, 0x78 };
int key_index = 0;
volatile BYTE send_keys_enabled = 0;
DWORD wait_counter = KEY_DELAY;
DWORD wait_tick;

void InitHardware()
{
	//Set up RAM mapping just beyond our own code
	BANK0PAL = BANK0_PA>>9;
	BANK0PAH = BANK0_PA>>17;
	BANK1VA  = BANK1_VA>>8;
	BANK1PAL = BANK1_PA>>9;
	BANK1PAH = BANK1_PA>>17;
	BANK2VA  = BANK2_VA>>8;
	BANK2PAL = BANK2_PA>>9;
	BANK2PAH = BANK2_PA>>17;

	__asm
	.db 0x90
	.db 0xF8
	.db 0x0A
	.db 0x74
	.db 0x1F
	.db 0xF0
	.db 0x90
	.db 0xF8
	.db 0x0E
	.db 0xE4
	.db 0xF0
	.db 0x90
	.db 0xF8
	.db 0x09
	.db 0x74
	.db 0x2C
	.db 0xF0
	.db 0x90
	.db 0xF8
	.db 0x10
	.db 0x74
	.db 0x80
	.db 0xF0
	.db 0xA3
	.db 0xE4
	.db 0xF0
	.db 0x90
	.db 0xF0
	.db 0x09
	.db 0xE0
	.db 0x54
	.db 0x07
	.db 0x64
	.db 0x04
	jnz HELL
	.db 0x90
	.db 0xFA
	.db 0x60
	.db 0xE4
	.db 0xF0
	.db 0xA3
	.db 0x74
	.db 0x0F
	.db 0xF0
	.db 0xA3
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x64
	.db 0x74
	.db 0x08
	.db 0xF0
	.db 0xA3
	.db 0x04
	.db 0xF0
	.db 0xA3
	.db 0x14
	.db 0xF0
	.db 0xA3
	.db 0x04
	.db 0xF0
	sjmp HEAVEN
	HELL:
	.db 0x90
	.db 0xFA
	.db 0x60
	.db 0xE4
	.db 0xF0
	.db 0xA3
	.db 0x74
	.db 0x0F
	.db 0xF0
	.db 0xA3
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x64
	.db 0x74
	.db 0x02
	.db 0xF0
	.db 0xA3
	.db 0xF0
	.db 0xA3
	.db 0xF0
	.db 0xA3
	.db 0xF0
	HEAVEN:
	.db 0x90
	.db 0xFF
	.db 0x00
	.db 0xE0
	.db 0x54
	.db 0xFB
	.db 0xF0
	.db 0xE0
	.db 0x44
	.db 0x04
	.db 0xF0
	.db 0xE0
	.db 0x44
	.db 0x10
	.db 0xF0
	.db 0xE0
	.db 0x54
	.db 0xFC
	.db 0xF0
	.db 0x90
	.db 0xFF
	.db 0x03
	.db 0x74
	.db 0xC1
	.db 0xF0
	.db 0x90
	.db 0xFF
	.db 0x0C
	.db 0xE0
	.db 0x30
	.db 0xE0
	.db 0xF9
	.db 0x90
	.db 0xFF
	.db 0x13
	.db 0xE0
	.db 0x54
	.db 0xFE
	.db 0xF0
	.db 0x90
	.db 0xFF
	.db 0x0C
	.db 0xE0
	.db 0x20
	.db 0xE1
	.db 0x07
	.db 0x90
	.db 0xFF
	.db 0x13
	.db 0xE0
	.db 0x44
	.db 0x10
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x6F
	.db 0xE0
	.db 0x44
	.db 0x1D
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x14
	.db 0xE0
	.db 0x54
	.db 0xFD
	.db 0xF0
	.db 0xA3
	.db 0xE0
	.db 0x44
	.db 0x02
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x21
	.db 0x74
	.db 0x07
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x20
	.db 0xE4
	.db 0xF0
	__endasm;

	XVAL(0xFA68) &= 0xF7;
	XVAL(0xFA69) &= 0xF7;
	XVAL(0xFA6A) &= 0xF7;
	XVAL(0xFA6B) &= 0xF7;

	TMOD = 0x11;
	TH0 = 0xF0;
	TL0 = 0x5F;
	TH1 = 0xF0;
	TL1 = 0x5F;
	IP = 1;
	TCON = 0x10;
	SCON = 0;
	IE = 0x80;
}

void DoUSBRelatedInit()
{
	if (WARMSTATUS & 2)
	{
		return;
	}

	REGBANK = 5;
	__asm
	.db 0x90
	.db 0xF2
	.db 0x00
	.db 0xE0
	.db 0x54
	.db 0xFE
	.db 0xF0
	.db 0x90
	.db 0xF0
	.db 0x00
	.db 0x74
	.db 0x05
	.db 0xF0
	.db 0x90
	.db 0xF2
	.db 0x13
	.db 0x74
	.db 0x30
	.db 0xF0
	.db 0x90
	.db 0x6C
	.db 0xD1
	.db 0xE0
	.db 0xFF
	.db 0x70
	.db 0x0C
	.db 0x90
	.db 0x6C
	.db 0xD0
	.db 0xE0
	.db 0x70
	.db 0x06
	.db 0x90
	.db 0x6C
	.db 0xD2
	.db 0xE0
	.db 0x60
	.db 0x1B
	.db 0x90
	.db 0x6C
	.db 0xD2
	.db 0xE0
	.db 0x90
	.db 0xF2
	.db 0x14
	.db 0xF0
	.db 0x90
	.db 0x6C
	.db 0xD0
	.db 0xE0
	.db 0x90
	.db 0xF2
	.db 0x15
	.db 0xF0
	.db 0xA3
	.db 0xE0
	.db 0x4F
	.db 0xF0
	.db 0x90
	.db 0xF2
	.db 0x13
	.db 0xE0
	.db 0x54
	.db 0xEF
	.db 0xF0
	.db 0x90
	.db 0x6C
	.db 0xD4
	.db 0xE0
	.db 0xFF
	.db 0x70
	.db 0x0C
	.db 0x90
	.db 0x6C
	.db 0xD3
	.db 0xE0
	.db 0x70
	.db 0x06
	.db 0x90
	.db 0x6C
	.db 0xD5
	.db 0xE0
	.db 0x60
	.db 0x36
	.db 0x90
	.db 0xF2
	.db 0x13
	.db 0xE0
	.db 0x4F
	.db 0xF0
	.db 0x90
	.db 0x6C
	.db 0xD3
	.db 0xE0
	.db 0xFE
	.db 0x90
	.db 0xF2
	.db 0x12
	.db 0xF0
	.db 0x90
	.db 0x6C
	.db 0xD5
	.db 0xE0
	.db 0x90
	.db 0xF2
	.db 0x11
	.db 0xF0
	.db 0xEE
	.db 0x24
	.db 0x9A
	.db 0x90
	.db 0xF2
	.db 0x17
	.db 0xF0
	.db 0xA3
	.db 0xE0
	.db 0x54
	.db 0xF0
	.db 0xF0
	.db 0xE0
	.db 0x4F
	.db 0xF0
	.db 0x90
	.db 0x6C
	.db 0xD3
	.db 0xE0
	.db 0xC3
	.db 0x94
	.db 0x66
	.db 0x50
	.db 0x07
	.db 0x90
	.db 0xF2
	.db 0x18
	.db 0xE0
	.db 0x44
	.db 0x0F
	.db 0xF0
	.db 0x90
	.db 0xF2
	.db 0x28
	.db 0x74
	.db 0x24
	.db 0xF0
	.db 0x90
	.db 0xF2
	.db 0x10
	.db 0xE0
	.db 0x54
	.db 0xF7
	.db 0xF0
	.db 0x90
	.db 0xF0
	.db 0x00
	.db 0xE4
	.db 0xF0
	.db 0x90
	.db 0xF0
	.db 0x14
	.db 0xE0
	.db 0x54
	.db 0xBF
	.db 0xF0
	.db 0x90
	.db 0xFA
	.db 0x6F
	.db 0xE0
	.db 0x44
	.db 0x10
	.db 0xF0
	.db 0x90
	.db 0xF0
	.db 0x14
	.db 0xE0
	.db 0x54
	.db 0x03
	.db 0x60
	.db 0xF8
	.db 0x90
	.db 0xFA
	.db 0x6B
	.db 0x74
	.db 0xFF
	.db 0xF0
	__endasm;
}

void SendKey(BYTE code, BYTE modifiers)
{
	int i;

	EP3.cs = 0;
	while (EP3.cs & 0x40);

	EP3.fifo = modifiers;
	EP3.fifo = 0;
	EP3.fifo = code;
	for (i = 0; i < 5; i++)
	{
		EP3.fifo = 0;
	}

	EP3.len_l = 8;
	EP3.len_m = 0;
	EP3.len_h = 0;
	EP3.cs = 0x40;
}

void main()
{
	InitHardware();
	DoUSBRelatedInit();
	InitUSB();
	InitTicks();
	InitLED();
	LEDBlink();

	while (1)
	{
		HandleUSBEvents();

		if (wait_tick++ >= KEY_DELAY)
		{
			if (wait_counter < KEY_DELAY)
			{
				wait_counter++;
			}
		}
		
		if (send_keys_enabled && wait_counter >= KEY_DELAY)
		{
			if (keyData[key_index])
			{
				//Send this key, with some padding before, since something's wonky with endpoint 3
				SendKey(0x00, 0x00);
				SendKey(0x00, 0x00);
				SendKey(0x00, 0x00);
				SendKey(0x00, 0x00);
				SendKey(keyData[key_index], keyData[key_index + 1]);
				SendKey(0x00, 0x00);
			}
			else
			{
				//Wait a while
				wait_counter = 0;
				wait_tick = 0;
			}

			//Move to next key
			key_index += 2;
			
			//Are we done?
			if (key_index >= sizeof(keyData))
			{
				send_keys_enabled = 0;
			}
		}
	}
}
